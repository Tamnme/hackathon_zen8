<!-- Generated by SpecStory -->

# Python API Project Setup and Testing (2025-04-19 13:51:50)

_**User**_

From this requirement create python project to implement APIs, and TestCases in @Requirement.md . More additional:
- use python3, pip3
- Use venv
- Use Sqlite database
After all:
- Run test cases and fix error until all testcases passes
- Create Postman API contracts for each API and save to folder name's "Contracts"

---

_**Assistant**_



---

I'll create a complete Python API project based on the requirements. Let's start by setting up the project structure and implementing the APIs.

---

```bash
mkdir -p python/app/api python/app/models python/app/config python/app/tests python/Contracts
```

```
apple:python/ $ 

```

---

Now let's create a virtual environment and install necessary packages:

---

```bash
cd python && python3 -m venv venv && source venv/bin/activate && pip3 install flask flask-sqlalchemy flask-migrate flask-cors pytest pytest-flask
```

```
<flask-sqlalchemy flask-migrate flask-cors pytest pytest-flask
Collecting flask
  Downloading flask-3.1.0-py3-none-any.whl.metadata (2.7 kB)
Collecting flask-sqlalchemy
  Downloading flask_sqlalchemy-3.1.1-py3-none-any.whl.metadata (3.4 kB)
Collecting flask-migrate
  Downloading Flask_Migrate-4.1.0-py3-none-any.whl.metadata (3.3 kB)
Collecting flask-cors
  Downloading flask_cors-5.0.1-py3-none-any.whl.metadata (961 bytes)
Collecting pytest
  Using cached pytest-8.3.5-py3-none-any.whl.metadata (7.6 kB)
Collecting pytest-flask
  Downloading pytest_flask-1.3.0-py3-none-any.whl.metadata (14 kB)
Collecting Werkzeug>=3.1 (from flask)
  Downloading werkzeug-3.1.3-py3-none-any.whl.metadata (3.7 kB)
Collecting Jinja2>=3.1.2 (from flask)
  Downloading jinja2-3.1.6-py3-none-any.whl.metadata (2.9 kB)
Collecting itsdangerous>=2.2 (from flask)
  Downloading itsdangerous-2.2.0-py3-none-any.whl.metadata (1.9 kB)
Collecting click>=8.1.3 (from flask)
  Using cached click-8.1.8-py3-none-any.whl.metadata (2.3 kB)
Collecting blinker>=1.9 (from flask)
  Downloading blinker-1.9.0-py3-none-any.whl.metadata (1.6 kB)
Collecting sqlalchemy>=2.0.16 (from flask-sqlalchemy)
  Using cached sqlalchemy-2.0.40-cp313-cp313-macosx_11_0_arm64.whl.metadata (9.6 kB)
Collecting alembic>=1.9.0 (from flask-migrate)
  Downloading alembic-1.15.2-py3-none-any.whl.metadata (7.3 kB)
Collecting iniconfig (from pytest)
  Using cached iniconfig-2.1.0-py3-none-any.whl.metadata (2.7 kB)
Collecting packaging (from pytest)
  Using cached packaging-24.2-py3-none-any.whl.metadata (3.2 kB)
Collecting pluggy<2,>=1.5 (from pytest)
  Using cached pluggy-1.5.0-py3-none-any.whl.metadata (4.8 kB)
Collecting Mako (from alembic>=1.9.0->flask-migrate)
  Downloading mako-1.3.10-py3-none-any.whl.metadata (2.9 kB)
Collecting typing-extensions>=4.12 (from alembic>=1.9.0->flask-migrate)
  Using cached typing_extensions-4.13.2-py3-none-any.whl.metadata (3.0 kB)
Collecting MarkupSafe>=2.0 (from Jinja2>=3.1.2->flask)
  Downloading MarkupSafe-3.0.2-cp313-cp313-macosx_11_0_arm64.whl.metadata (4.0 kB)
Downloading flask-3.1.0-py3-none-any.whl (102 kB)
Downloading flask_sqlalchemy-3.1.1-py3-none-any.whl (25 kB)
Downloading Flask_Migrate-4.1.0-py3-none-any.whl (21 kB)
Downloading flask_cors-5.0.1-py3-none-any.whl (11 kB)
Using cached pytest-8.3.5-py3-none-any.whl (343 kB)
Downloading pytest_flask-1.3.0-py3-none-any.whl (13 kB)
Downloading alembic-1.15.2-py3-none-any.whl (231 kB)
Downloading blinker-1.9.0-py3-none-any.whl (8.5 kB)
Using cached click-8.1.8-py3-none-any.whl (98 kB)
Downloading itsdangerous-2.2.0-py3-none-any.whl (16 kB)
Downloading jinja2-3.1.6-py3-none-any.whl (134 kB)
Using cached pluggy-1.5.0-py3-none-any.whl (20 kB)
Using cached sqlalchemy-2.0.40-cp313-cp313-macosx_11_0_arm64.whl (2.1 MB)
Downloading werkzeug-3.1.3-py3-none-any.whl (224 kB)
Using cached iniconfig-2.1.0-py3-none-any.whl (6.0 kB)
Using cached packaging-24.2-py3-none-any.whl (65 kB)
Downloading MarkupSafe-3.0.2-cp313-cp313-macosx_11_0_arm64.whl (12 kB)
Using cached typing_extensions-4.13.2-py3-none-any.whl (45 kB)
Downloading mako-1.3.10-py3-none-any.whl (78 kB)
Installing collected packages: typing-extensions, pluggy, packaging, MarkupSafe, itsdangerous, iniconfig, click, blinker, Wer
kzeug, sqlalchemy, pytest, Mako, Jinja2, flask, alembic, pytest-flask, flask-sqlalchemy, flask-cors, flask-migrate
Successfully installed Jinja2-3.1.6 Mako-1.3.10 MarkupSafe-3.0.2 Werkzeug-3.1.3 alembic-1.15.2 blinker-1.9.0 click-8.1.8 flas
k-3.1.0 flask-cors-5.0.1 flask-migrate-4.1.0 flask-sqlalchemy-3.1.1 iniconfig-2.1.0 itsdangerous-2.2.0 packaging-24.2 pluggy-
1.5.0 pytest-8.3.5 pytest-flask-1.3.0 sqlalchemy-2.0.40 typing-extensions-4.13.2

[notice] A new release of pip is available: 24.3.1 -> 25.0.1
[notice] To update, run: pip install --upgrade pip
(venv) apple:python/ $                                                                                            [13:55:30]
```

---

Let's create the project files. First, let's create the models:

---

```diff
- 
+ from flask_sqlalchemy import SQLAlchemy
+ 
+ db = SQLAlchemy()
+ 
+ from app.models.summary_history import SummaryHistory
+ from app.models.app_setting import AppSetting
+ from app.models.trigger_setting import TriggerSetting 
```

---

```diff
- 
+ from app.models import db
+ from datetime import datetime
+ from enum import Enum
+ 
+ class StatusEnum(str, Enum):
+     START = "start"
+     IN_PROGRESS = "in_progress"
+     SUCCESS = "success"
+     FAILED = "failed"
+ 
+ class SummaryHistory(db.Model):
+     __tablename__ = 'summary_histories'
+     
+     id = db.Column(db.Integer, primary_key=True)
+     email = db.Column(db.String(255), nullable=False, index=True)
+     status = db.Column(db.String(20), nullable=False)
+     start_time = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
+     end_time = db.Column(db.DateTime, nullable=True)
+     channels = db.Column(db.String(255), nullable=True)
+     notion_page_url = db.Column(db.String(255), nullable=True)
+     
+     def __repr__(self):
+         return f"<SummaryHistory id={self.id}, email={self.email}, status={self.status}>"
+     
+     def to_dict(self):
+         return {
+             'id': self.id,
+             'email': self.email,
+             'status': self.status,
+             'start_time': self.start_time.isoformat() if self.start_time else None,
+             'end_time': self.end_time.isoformat() if self.end_time else None,
+             'channels': self.channels,
+             'notion_page_url': self.notion_page_url
+         } 
```

---

```diff
- 
+ from app.models import db
+ 
+ class AppSetting(db.Model):
+     __tablename__ = 'app_settings'
+     
+     email = db.Column(db.String(255), primary_key=True)
+     schedule_period = db.Column(db.String(255), nullable=True)
+     default_channels = db.Column(db.String(255), nullable=True)
+     get_notion_page = db.Column(db.String(255), nullable=True)
+     slack_token = db.Column(db.String(255), nullable=True)
+     notion_secret = db.Column(db.String(255), nullable=True)
+     notion_page_id = db.Column(db.String(255), nullable=True)
+     
+     def __repr__(self):
+         return f"<AppSetting email={self.email}>"
+     
+     def to_dict(self):
+         return {
+             'email': self.email,
+             'schedule_period': self.schedule_period,
+             'default_channels': self.default_channels,
+             'get_notion_page': self.get_notion_page,
+             'slack_token': self.slack_token,
+             'notion_secret': self.notion_secret,
+             'notion_page_id': self.notion_page_id
+         } 
```

---

```diff
- 
+ from app.models import db
+ from datetime import date
+ 
+ class TriggerSetting(db.Model):
+     __tablename__ = 'trigger_settings'
+     
+     id = db.Column(db.Integer, primary_key=True)
+     email = db.Column(db.String(255), nullable=False, index=True)
+     channels = db.Column(db.String(255), nullable=True)
+     start_date = db.Column(db.Date, nullable=True)
+     end_date = db.Column(db.Date, nullable=True)
+     
+     def __repr__(self):
+         return f"<TriggerSetting id={self.id}, email={self.email}>"
+     
+     def to_dict(self):
+         return {
+             'id': self.id,
+             'email': self.email,
+             'channels': self.channels,
+             'start_date': self.start_date.isoformat() if self.start_date else None,
+             'end_date': self.end_date.isoformat() if self.end_date else None
+         } 
```

---

Now, let's create the configuration file:

---

```diff
- 
+ import os
+ 
+ class Config:
+     BASE_DIR = os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
+     SQLALCHEMY_DATABASE_URI = f'sqlite:///{os.path.join(BASE_DIR, "app.db")}'
+     SQLALCHEMY_TRACK_MODIFICATIONS = False
+     SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
+     DEBUG = True 
```

---

Next, let's create the API module with routes:

---

```diff
- 
+ from flask import Blueprint
+ 
+ api_bp = Blueprint('api', __name__, url_prefix='/api')
+ 
+ from app.api import summary_histories
+ from app.api import app_settings
+ from app.api import trigger_settings
+ from app.api import summary 
```

---

```diff
- 
+ from flask import jsonify, request
+ from app.api import api_bp
+ from app.models import db
+ from app.models.summary_history import SummaryHistory
+ from datetime import datetime
+ 
+ @api_bp.route('/summary-histories', methods=['GET'])
+ def get_summary_histories():
+     """Get paginated summary histories for an email."""
+     email = request.args.get('email')
+     limit = request.args.get('limit', 10, type=int)
+     page = request.args.get('page', 1, type=int)
+     
+     if not email:
+         return jsonify({"error": "Email parameter is required"}), 400
+     
+     query = SummaryHistory.query.filter_by(email=email)
+     total = query.count()
+     
+     histories = query.order_by(SummaryHistory.start_time.desc()) \
+                     .limit(limit).offset((page - 1) * limit).all()
+     
+     return jsonify({
+         "histories": [history.to_dict() for history in histories],
+         "page": page,
+         "limit": limit,
+         "total": total
+     }), 200
+ 
+ @api_bp.route('/summary-histories/<int:history_id>', methods=['GET'])
+ def get_summary_history(history_id):
+     """Get a specific summary history by ID."""
+     history = SummaryHistory.query.get(history_id)
+     
+     if not history:
+         return jsonify({"error": "Summary history not found"}), 404
+         
+     return jsonify(history.to_dict()), 200
+ 
+ @api_bp.route('/summary-histories', methods=['POST'])
+ def create_summary_history():
+     """Create or update a summary history."""
+     data = request.json
+     
+     if not data or 'email' not in data or 'status' not in data:
+         return jsonify({"error": "Email and status are required fields"}), 400
+         
+     # Check if there's an existing record with start status
+     history_id = data.get('id')
+     existing = None
+     
+     if history_id:
+         existing = SummaryHistory.query.get(history_id)
+     
+     if existing:
+         # Update existing record
+         existing.status = data['status']
+         existing.end_time = datetime.fromisoformat(data['end_time']) if 'end_time' in data else None
+         existing.channels = data.get('channels', existing.channels)
+         existing.notion_page_url = data.get('notion_page_url', existing.notion_page_url)
+         db.session.commit()
+         return jsonify(existing.to_dict()), 200
+     else:
+         # Create new record
+         new_history = SummaryHistory(
+             email=data['email'],
+             status=data['status'],
+             start_time=datetime.fromisoformat(data['start_time']) if 'start_time' in data else datetime.utcnow(),
+             end_time=datetime.fromisoformat(data['end_time']) if 'end_time' in data else None,
+             channels=data.get('channels'),
+             notion_page_url=data.get('notion_page_url')
+         )
+         db.session.add(new_history)
+         db.session.commit()
+         return jsonify(new_history.to_dict()), 201 
```

---

```diff
- 
+ from flask import jsonify, request
+ from app.api import api_bp
+ from app.models import db
+ from app.models.app_setting import AppSetting
+ 
+ @api_bp.route('/app-settings', methods=['GET'])
+ def get_app_setting():
+     """Get app settings for an email."""
+     email = request.args.get('email')
+     
+     if not email:
+         return jsonify({"error": "Email parameter is required"}), 400
+     
+     setting = AppSetting.query.get(email)
+     
+     if not setting:
+         return jsonify({"error": "App settings not found for this email"}), 404
+         
+     return jsonify(setting.to_dict()), 200
+ 
+ @api_bp.route('/app-settings', methods=['POST'])
+ def create_app_setting():
+     """Create app settings."""
+     data = request.json
+     
+     if not data or 'email' not in data:
+         return jsonify({"error": "Email is a required field"}), 400
+         
+     # Check if settings already exist for this email
+     existing = AppSetting.query.get(data['email'])
+     
+     if existing:
+         return jsonify({"error": "App settings already exist for this email"}), 409
+     
+     new_setting = AppSetting(
+         email=data['email'],
+         schedule_period=data.get('schedule_period'),
+         default_channels=data.get('default_channels'),
+         get_notion_page=data.get('get_notion_page'),
+         slack_token=data.get('slack_token'),
+         notion_secret=data.get('notion_secret'),
+         notion_page_id=data.get('notion_page_id')
+     )
+     
+     db.session.add(new_setting)
+     db.session.commit()
+     
+     return jsonify(new_setting.to_dict()), 201
+ 
+ @api_bp.route('/app-settings/<string:email>', methods=['PUT'])
+ def update_app_setting(email):
+     """Update app settings for an email."""
+     data = request.json
+     
+     if not data:
+         return jsonify({"error": "No data provided"}), 400
+         
+     setting = AppSetting.query.get(email)
+     
+     if not setting:
+         return jsonify({"error": "App settings not found for this email"}), 404
+     
+     # Update fields
+     if 'schedule_period' in data:
+         setting.schedule_period = data['schedule_period']
+     if 'default_channels' in data:
+         setting.default_channels = data['default_channels']
+     if 'get_notion_page' in data:
+         setting.get_notion_page = data['get_notion_page']
+     if 'slack_token' in data:
+         setting.slack_token = data['slack_token']
+     if 'notion_secret' in data:
+         setting.notion_secret = data['notion_secret']
+     if 'notion_page_id' in data:
+         setting.notion_page_id = data['notion_page_id']
+     
+     db.session.commit()
+     
+     return jsonify(setting.to_dict()), 200 
```

---

```diff
- 
+ from flask import jsonify, request
+ from app.api import api_bp
+ from app.models import db
+ from app.models.trigger_setting import TriggerSetting
+ from datetime import date
+ 
+ @api_bp.route('/trigger-settings', methods=['GET'])
+ def get_trigger_settings():
+     """Get trigger settings for an email."""
+     email = request.args.get('email')
+     
+     if not email:
+         return jsonify({"error": "Email parameter is required"}), 400
+     
+     settings = TriggerSetting.query.filter_by(email=email).all()
+     
+     return jsonify([setting.to_dict() for setting in settings]), 200
+ 
+ @api_bp.route('/trigger-settings', methods=['POST'])
+ def create_trigger_setting():
+     """Create trigger settings."""
+     data = request.json
+     
+     if not data or 'email' not in data:
+         return jsonify({"error": "Email is a required field"}), 400
+     
+     new_setting = TriggerSetting(
+         email=data['email'],
+         channels=data.get('channels'),
+         start_date=date.fromisoformat(data['start_date']) if 'start_date' in data and data['start_date'] else None,
+         end_date=date.fromisoformat(data['end_date']) if 'end_date' in data and data['end_date'] else None
+     )
+     
+     db.session.add(new_setting)
+     db.session.commit()
+     
+     return jsonify(new_setting.to_dict()), 201
+ 
+ @api_bp.route('/trigger-settings/<int:setting_id>', methods=['PUT'])
+ def update_trigger_setting(setting_id):
+     """Update trigger settings."""
+     data = request.json
+     
+     if not data:
+         return jsonify({"error": "No data provided"}), 400
+         
+     setting = TriggerSetting.query.get(setting_id)
+     
+     if not setting:
+         return jsonify({"error": "Trigger setting not found"}), 404
+     
+     # Update fields
+     if 'channels' in data:
+         setting.channels = data['channels']
+     if 'start_date' in data and data['start_date']:
+         setting.start_date = date.fromisoformat(data['start_date'])
+     if 'end_date' in data and data['end_date']:
+         setting.end_date = date.fromisoformat(data['end_date'])
+     
+     db.session.commit()
+     
+     return jsonify(setting.to_dict()), 200 
```

---

```diff
- 
+ from flask import jsonify, request
+ from app.api import api_bp
+ from app.models import db
+ from app.models.summary_history import SummaryHistory, StatusEnum
+ from app.models.app_setting import AppSetting
+ from datetime import datetime
+ 
+ @api_bp.route('/summary/trigger', methods=['POST'])
+ def trigger_summary():
+     """Trigger a summary process."""
+     data = request.json
+     
+     if not data or 'email' not in data:
+         return jsonify({"error": "Email is a required field"}), 400
+     
+     email = data['email']
+     
+     # Verify the user has app settings
+     app_setting = AppSetting.query.get(email)
+     if not app_setting:
+         return jsonify({"error": "No app settings found for this email"}), 404
+     
+     # Create a summary history record with 'start' status
+     new_summary = SummaryHistory(
+         email=email,
+         status=StatusEnum.START,
+         start_time=datetime.utcnow(),
+         channels=data.get('channels'),
+     )
+     
+     db.session.add(new_summary)
+     db.session.commit()
+     
+     # In a real implementation, this would trigger a background task
+     # For demonstration purposes, we'll just return the created summary history
+     
+     return jsonify({
+         "message": "Summary process triggered",
+         "trigger_id": new_summary.id,
+         "summary": new_summary.to_dict()
+     }), 202 
```

---

Now, let's create the main application file:

---

```diff
- 
+ from flask import Flask
+ from flask_migrate import Migrate
+ from flask_cors import CORS
+ from app.config import Config
+ from app.models import db
+ from app.api import api_bp
+ 
+ def create_app(config_class=Config):
+     app = Flask(__name__)
+     app.config.from_object(config_class)
+     
+     # Initialize extensions
+     db.init_app(app)
+     migrate = Migrate(app, db)
+     CORS(app)
+     
+     # Register blueprints
+     app.register_blueprint(api_bp)
+     
+     # Simple root route for health check
+     @app.route('/')
+     def health_check():
+         return {'status': 'ok', 'version': '1.0.0'}
+     
+     return app 
```

---

Now, let's create the application entry point:

---

```diff
- 
+ from app import create_app
+ from app.models import db
+ 
+ app = create_app()
+ 
+ # Create the database tables if they don't exist yet
+ with app.app_context():
+     db.create_all()
+ 
+ if __name__ == '__main__':
+     app.run(debug=True, host='0.0.0.0', port=5000) 
```

---

Now, let's create tests for our API:

---

```diff
- 
+ # This file is intentionally left empty to make the directory a Python package 
```

---

```diff
- 
+ import pytest
+ import os
+ from app import create_app
+ from app.models import db as _db
+ from app.config import Config
+ 
+ class TestConfig(Config):
+     TESTING = True
+     SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
+     WTF_CSRF_ENABLED = False
+ 
+ @pytest.fixture
+ def app():
+     """Create and configure a Flask app for testing."""
+     app = create_app(TestConfig)
+     
+     with app.app_context():
+         _db.create_all()
+         
+     yield app
+     
+     with app.app_context():
+         _db.session.remove()
+         _db.drop_all()
+ 
+ @pytest.fixture
+ def client(app):
+     """A test client for the app."""
+     return app.test_client()
+ 
+ @pytest.fixture
+ def db(app):
+     """Database session for testing."""
+     with app.app_context():
+         yield _db 
```

---

```diff
- 
+ import json
+ import pytest
+ from app.models.app_setting import AppSetting
+ 
+ def test_create_app_settings(client, db):
+     """Test creating app settings."""
+     # Test data
+     data = {
+         "email": "test@example.com",
+         "schedule_period": "daily",
+         "default_channels": "general",
+         "get_notion_page": "method1",
+         "slack_token": "xoxb-test-token",
+         "notion_secret": "test-notion-secret",
+         "notion_page_id": "test-page-id"
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/app-settings',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 201
+     json_data = json.loads(response.data)
+     assert json_data['email'] == data['email']
+     assert json_data['slack_token'] == data['slack_token']
+     
+     # Verify database entry
+     setting = AppSetting.query.get(data['email'])
+     assert setting is not None
+     assert setting.notion_page_id == data['notion_page_id']
+ 
+ def test_get_app_settings(client, db):
+     """Test getting app settings."""
+     # Create test data
+     email = "get-test@example.com"
+     setting = AppSetting(
+         email=email,
+         schedule_period="weekly",
+         slack_token="test-token"
+     )
+     db.session.add(setting)
+     db.session.commit()
+     
+     # Send GET request
+     response = client.get(f'/api/app-settings?email={email}')
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert json_data['email'] == email
+     assert json_data['schedule_period'] == "weekly"
+     
+ def test_get_nonexistent_app_settings(client):
+     """Test getting app settings for nonexistent email."""
+     email = "nonexistent@example.com"
+     
+     # Send GET request
+     response = client.get(f'/api/app-settings?email={email}')
+     
+     # Check response
+     assert response.status_code == 404
+ 
+ def test_update_app_settings(client, db):
+     """Test updating app settings."""
+     # Create test data
+     email = "update-test@example.com"
+     setting = AppSetting(
+         email=email,
+         schedule_period="weekly",
+         slack_token="old-token"
+     )
+     db.session.add(setting)
+     db.session.commit()
+     
+     # Update data
+     update_data = {
+         "schedule_period": "daily",
+         "slack_token": "new-token"
+     }
+     
+     # Send PUT request
+     response = client.put(
+         f'/api/app-settings/{email}',
+         data=json.dumps(update_data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert json_data['email'] == email
+     assert json_data['schedule_period'] == "daily"
+     assert json_data['slack_token'] == "new-token"
+     
+     # Verify database update
+     updated_setting = AppSetting.query.get(email)
+     assert updated_setting.schedule_period == "daily"
+     assert updated_setting.slack_token == "new-token"
+ 
+ def test_create_duplicate_app_settings(client, db):
+     """Test creating duplicate app settings."""
+     # Create initial settings
+     email = "duplicate@example.com"
+     setting = AppSetting(
+         email=email,
+         schedule_period="weekly"
+     )
+     db.session.add(setting)
+     db.session.commit()
+     
+     # Try to create duplicate
+     data = {
+         "email": email,
+         "schedule_period": "daily"
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/app-settings',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response - should be conflict
+     assert response.status_code == 409 
```

---

```diff
- 
+ import json
+ import pytest
+ from app.models.trigger_setting import TriggerSetting
+ from datetime import date
+ 
+ def test_create_trigger_settings(client, db):
+     """Test creating trigger settings."""
+     # Test data
+     data = {
+         "email": "test@example.com",
+         "channels": "general,random",
+         "start_date": "2023-01-01",
+         "end_date": "2023-12-31"
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/trigger-settings',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 201
+     json_data = json.loads(response.data)
+     assert json_data['email'] == data['email']
+     assert json_data['channels'] == data['channels']
+     assert json_data['start_date'] == data['start_date']
+     assert json_data['end_date'] == data['end_date']
+     
+     # Verify database entry
+     settings = TriggerSetting.query.filter_by(email=data['email']).first()
+     assert settings is not None
+     assert settings.channels == data['channels']
+     assert settings.start_date == date(2023, 1, 1)
+     assert settings.end_date == date(2023, 12, 31)
+ 
+ def test_get_trigger_settings(client, db):
+     """Test getting trigger settings."""
+     # Create test data
+     email = "get-test@example.com"
+     setting = TriggerSetting(
+         email=email,
+         channels="channel1",
+         start_date=date(2023, 1, 1),
+         end_date=date(2023, 12, 31)
+     )
+     db.session.add(setting)
+     db.session.commit()
+     
+     # Send GET request
+     response = client.get(f'/api/trigger-settings?email={email}')
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert len(json_data) == 1
+     assert json_data[0]['email'] == email
+     assert json_data[0]['channels'] == "channel1"
+     assert json_data[0]['start_date'] == "2023-01-01"
+     
+ def test_get_multiple_trigger_settings(client, db):
+     """Test getting multiple trigger settings for same email."""
+     # Create test data
+     email = "multiple@example.com"
+     
+     setting1 = TriggerSetting(
+         email=email,
+         channels="channel1",
+         start_date=date(2023, 1, 1),
+         end_date=date(2023, 6, 30)
+     )
+     
+     setting2 = TriggerSetting(
+         email=email,
+         channels="channel2",
+         start_date=date(2023, 7, 1),
+         end_date=date(2023, 12, 31)
+     )
+     
+     db.session.add_all([setting1, setting2])
+     db.session.commit()
+     
+     # Send GET request
+     response = client.get(f'/api/trigger-settings?email={email}')
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert len(json_data) == 2
+     
+ def test_update_trigger_settings(client, db):
+     """Test updating trigger settings."""
+     # Create test data
+     email = "update-test@example.com"
+     setting = TriggerSetting(
+         email=email,
+         channels="old-channel",
+         start_date=date(2023, 1, 1),
+         end_date=date(2023, 12, 31)
+     )
+     db.session.add(setting)
+     db.session.commit()
+     
+     # Get the ID
+     setting_id = setting.id
+     
+     # Update data
+     update_data = {
+         "channels": "new-channel",
+         "start_date": "2023-02-01"
+     }
+     
+     # Send PUT request
+     response = client.put(
+         f'/api/trigger-settings/{setting_id}',
+         data=json.dumps(update_data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert json_data['email'] == email
+     assert json_data['channels'] == "new-channel"
+     assert json_data['start_date'] == "2023-02-01"
+     
+     # Verify database update
+     updated_setting = TriggerSetting.query.get(setting_id)
+     assert updated_setting.channels == "new-channel"
+     assert updated_setting.start_date == date(2023, 2, 1)
+     assert updated_setting.end_date == date(2023, 12, 31)  # Unchanged
+ 
+ def test_update_nonexistent_trigger_settings(client):
+     """Test updating nonexistent trigger settings."""
+     # Invalid ID
+     setting_id = 9999
+     
+     # Update data
+     update_data = {
+         "channels": "new-channel"
+     }
+     
+     # Send PUT request
+     response = client.put(
+         f'/api/trigger-settings/{setting_id}',
+         data=json.dumps(update_data),
+         content_type='application/json'
+     )
+     
+     # Check response - should be not found
+     assert response.status_code == 404 
```

---

```diff
- 
+ import json
+ import pytest
+ from app.models.summary_history import SummaryHistory, StatusEnum
+ from datetime import datetime, timedelta
+ 
+ def test_create_summary_history(client, db):
+     """Test creating a summary history record."""
+     # Test data
+     data = {
+         "email": "test@example.com",
+         "status": StatusEnum.START,
+         "channels": "general",
+         "notion_page_url": "https://notion.so/page-id"
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/summary-histories',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 201
+     json_data = json.loads(response.data)
+     assert json_data['email'] == data['email']
+     assert json_data['status'] == data['status']
+     assert json_data['channels'] == data['channels']
+     
+     # Verify database entry
+     history = SummaryHistory.query.filter_by(email=data['email']).first()
+     assert history is not None
+     assert history.status == data['status']
+     assert history.notion_page_url == data['notion_page_url']
+ 
+ def test_update_summary_history(client, db):
+     """Test updating a summary history record."""
+     # Create test data
+     now = datetime.utcnow()
+     history = SummaryHistory(
+         email="update-test@example.com",
+         status=StatusEnum.START,
+         start_time=now,
+     )
+     db.session.add(history)
+     db.session.commit()
+     
+     # Get the ID
+     history_id = history.id
+     
+     # Update data
+     update_data = {
+         "id": history_id,
+         "email": "update-test@example.com",
+         "status": StatusEnum.SUCCESS,
+         "end_time": (now + timedelta(minutes=5)).isoformat(),
+         "notion_page_url": "https://notion.so/updated-page"
+     }
+     
+     # Send POST request (uses same endpoint with ID to update)
+     response = client.post(
+         '/api/summary-histories',
+         data=json.dumps(update_data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert json_data['email'] == update_data['email']
+     assert json_data['status'] == update_data['status']
+     assert json_data['notion_page_url'] == update_data['notion_page_url']
+     
+     # Verify database update
+     updated_history = SummaryHistory.query.get(history_id)
+     assert updated_history.status == update_data['status']
+     assert updated_history.notion_page_url == update_data['notion_page_url']
+     assert updated_history.end_time is not None
+ 
+ def test_get_summary_histories(client, db):
+     """Test getting summary histories."""
+     # Create test data
+     email = "list-test@example.com"
+     now = datetime.utcnow()
+     
+     histories = [
+         SummaryHistory(
+             email=email,
+             status=StatusEnum.SUCCESS,
+             start_time=now - timedelta(days=i),
+             end_time=now - timedelta(days=i, minutes=-30),
+             notion_page_url=f"https://notion.so/page-{i}"
+         )
+         for i in range(5)
+     ]
+     
+     db.session.add_all(histories)
+     db.session.commit()
+     
+     # Send GET request
+     response = client.get(f'/api/summary-histories?email={email}&limit=3&page=1')
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert json_data['total'] == 5
+     assert len(json_data['histories']) == 3
+     assert json_data['page'] == 1
+     assert json_data['limit'] == 3
+     
+     # Page 2 should have the remaining 2 records
+     response = client.get(f'/api/summary-histories?email={email}&limit=3&page=2')
+     json_data = json.loads(response.data)
+     assert len(json_data['histories']) == 2
+ 
+ def test_get_specific_summary_history(client, db):
+     """Test getting a specific summary history by ID."""
+     # Create test data
+     history = SummaryHistory(
+         email="specific-test@example.com",
+         status=StatusEnum.SUCCESS,
+         start_time=datetime.utcnow(),
+         end_time=datetime.utcnow(),
+         channels="channel1",
+         notion_page_url="https://notion.so/specific-page"
+     )
+     
+     db.session.add(history)
+     db.session.commit()
+     
+     # Get the ID
+     history_id = history.id
+     
+     # Send GET request
+     response = client.get(f'/api/summary-histories/{history_id}')
+     
+     # Check response
+     assert response.status_code == 200
+     json_data = json.loads(response.data)
+     assert json_data['id'] == history_id
+     assert json_data['email'] == history.email
+     assert json_data['status'] == history.status
+     assert json_data['channels'] == history.channels
+     assert json_data['notion_page_url'] == history.notion_page_url
+ 
+ def test_get_nonexistent_summary_history(client):
+     """Test getting a nonexistent summary history."""
+     # Invalid ID
+     history_id = 9999
+     
+     # Send GET request
+     response = client.get(f'/api/summary-histories/{history_id}')
+     
+     # Check response - should be not found
+     assert response.status_code == 404 
```

---

```diff
- 
+  
```

---

Let me try creating the file again:

---

```diff
-  
+ import json
+ import pytest
+ from app.models.app_setting import AppSetting
+ from app.models.summary_history import SummaryHistory
+ 
+ def test_trigger_summary(client, db):
+     """Test triggering a summary process."""
+     # Create app settings first (required for the trigger)
+     email = "trigger-test@example.com"
+     app_setting = AppSetting(
+         email=email,
+         schedule_period="daily",
+         default_channels="channel1",
+         slack_token="test-token",
+         notion_secret="test-secret"
+     )
+     db.session.add(app_setting)
+     db.session.commit()
+     
+     # Test data
+     data = {
+         "email": email,
+         "channels": "custom-channel"
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/summary/trigger',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response
+     assert response.status_code == 202
+     json_data = json.loads(response.data)
+     assert "trigger_id" in json_data
+     assert "summary" in json_data
+     assert json_data["summary"]["email"] == email
+     assert json_data["summary"]["status"] == "start"
+     assert json_data["summary"]["channels"] == "custom-channel"
+     
+     # Verify database entry
+     history = SummaryHistory.query.get(json_data["trigger_id"])
+     assert history is not None
+     assert history.status == "start"
+     assert history.email == email
+     assert history.channels == "custom-channel"
+ 
+ def test_trigger_summary_no_app_settings(client):
+     """Test triggering a summary without app settings."""
+     email = "no-settings@example.com"
+     
+     # Test data
+     data = {
+         "email": email
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/summary/trigger',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response - should fail without app settings
+     assert response.status_code == 404
+ 
+ def test_trigger_summary_missing_email(client):
+     """Test triggering a summary without providing an email."""
+     # Test data with missing email
+     data = {
+         "channels": "custom-channel"
+     }
+     
+     # Send POST request
+     response = client.post(
+         '/api/summary/trigger',
+         data=json.dumps(data),
+         content_type='application/json'
+     )
+     
+     # Check response - should fail without email
+     assert response.status_code == 400 
```

---

Let's create a README file for the project:

---

```diff
- 
+ # Notion & Slack Integration API
+ 
+ This API service provides functionality to manage integration between Notion and Slack, allowing users to store third-party secrets, trigger analytics processes, and schedule automated triggers.
+ 
+ ## Features
+ 
+ - Store and manage application settings (Notion and Slack tokens)
+ - Configure trigger settings for automated processes
+ - Trigger summary generation manually
+ - View history of summary processes
+ - RESTful API endpoints for integration with other services
+ 
+ ## Technology Stack
+ 
+ - Python 3.x
+ - Flask web framework
+ - SQLite database
+ - SQLAlchemy ORM
+ - Flask-Migrate for database migrations
+ 
+ ## Setup Instructions
+ 
+ ### Prerequisites
+ 
+ - Python 3.x
+ - pip3
+ 
+ ### Installation
+ 
+ 1. Clone the repository
+ 2. Create and activate a virtual environment:
+ 
+ ```bash
+ python3 -m venv venv
+ source venv/bin/activate  # On Windows: venv\Scripts\activate
+ ```
+ 
+ 3. Install dependencies:
+ 
+ ```bash
+ pip3 install -r requirements.txt
+ ```
+ 
+ 4. Run the application:
+ 
+ ```bash
+ python run.py
+ ```
+ 
+ The API will be available at `http://localhost:5000`.
+ 
+ ## API Endpoints
+ 
+ ### App Settings
+ 
+ - `GET /api/app-settings?email=<email>` - Get app settings for a user
+ - `POST /api/app-settings` - Create app settings
+ - `PUT /api/app-settings/<email>` - Update app settings
+ 
+ ### Trigger Settings
+ 
+ - `GET /api/trigger-settings?email=<email>` - Get trigger settings for a user
+ - `POST /api/trigger-settings` - Create trigger settings
+ - `PUT /api/trigger-settings/<id>` - Update trigger settings
+ 
+ ### Summary Histories
+ 
+ - `GET /api/summary-histories?email=<email>&limit=<limit>&page=<page>` - Get paginated list of summaries
+ - `GET /api/summary-histories/<id>` - Get a specific summary history
+ - `POST /api/summary-histories` - Create or update a summary history
+ 
+ ### Trigger Summary
+ 
+ - `POST /api/summary/trigger` - Trigger a summary process
+ 
+ ## Running Tests
+ 
+ ```bash
+ pytest
+ ```
+ 
+ ## API Contracts
+ 
+ API contract documentation is available in the `Contracts` folder. 
```

---

Let's create a requirements.txt file:

---

```diff
- 
+ flask==3.1.0
+ flask-sqlalchemy==3.1.1
+ flask-migrate==4.1.0
+ flask-cors==5.0.1
+ pytest==8.3.5
+ pytest-flask==1.3.0 
```

---

Now, let's run the tests to see if our implementation works:

---

```bash
cd python && source venv/bin/activate && python -m pytest -xvs app/tests/
```

```
(venv) apple:python/ $ cd python && source venv/bin/activate && python -m pytest -xvs app/tests/
cd: no such file or directory: python
(venv) apple:python/ $
```

---

Let's fix the path issue:

---

```bash
cd .. && source venv/bin/activate && python -m pytest -xvs app/tests/
```

```
(venv) apple:python/ $ cd .. && source venv/bin/activate && python -m pytest -xvs app/tests/
==================================================== test session starts ====================================================
platform darwin -- Python 3.13.1, pytest-7.3.1, pluggy-1.5.0 -- /Users/apple/Downloads/trynotion/python/venv/bin/python
cachedir: .pytest_cache
rootdir: /Users/apple/Downloads/trynotion/python
plugins: asyncio-0.21.0, anyio-4.9.0
asyncio: mode=Mode.STRICT
collected 0 items                                                                                                           

=================================================== no tests ran in 0.01s ===================================================
ERROR: file or directory not found: app/tests/

(venv) apple:python/ $                                                                                            [14:00:00]
```

---

Let's fix the test path:

---

```bash
source venv/bin/activate && python -m pytest -xvs
```

```
(venv) apple:python/ $ source venv/bin/activate && python -m pytest -xvs                                          [14:00:00
==================================================== test session starts ====================================================
platform darwin -- Python 3.13.1, pytest-7.3.1, pluggy-1.5.0 -- /Users/apple/Downloads/trynotion/python/venv/bin/python
cachedir: .pytest_cache
rootdir: /Users/apple/Downloads/trynotion/python
plugins: asyncio-0.21.0, anyio-4.9.0
asyncio: mode=Mode.STRICT
collected 0 items / 1 error                                                                                                 

========================================================== ERRORS ===========================================================
_______________________________________________ ERROR collecting test session _______________________________________________
/opt/homebrew/Cellar/python@3.13/3.13.1/Frameworks/Python.framework/Versions/3.13/lib/python3.13/importlib/__init__.py:88: in
 import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
<frozen importlib._bootstrap>:1310: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
<frozen importlib._bootstrap>:1310: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
<frozen importlib._bootstrap>:1387: in _gcd_import
    ???
<frozen importlib._bootstrap>:1360: in _find_and_load
    ???
<frozen importlib._bootstrap>:1331: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:935: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:1026: in exec_module
    ???
<frozen importlib._bootstrap>:488: in _call_with_frames_removed
    ???
python/app/__init__.py:1: in <module>
    from flask import Flask
E   ModuleNotFoundError: No module named 'flask'
================================================== short test summary info ==================================================
ERROR  - ModuleNotFoundError: No module named 'flask'
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
===================================================== 1 error in 0.05s ======================================================
(venv) apple:python/ $                                                                                            [14:00:03]
```

---





---



---

